translation_unit: HEADER MAIN_METH_SEP SUB ID LPAREN RPAREN NEWLINE END SUB WHILE
##
## Ends in an error in state: 105.
##
## translation_unit -> HEADER list(NEWLINE) fxns MAIN_METH_SEP list(NEWLINE) fxn list(NEWLINE) . EOF [ # ]
##
## The known suffix of the stack is as follows:
## HEADER list(NEWLINE) fxns MAIN_METH_SEP list(NEWLINE) fxn list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 104, spurious reduction of production list(NEWLINE) ->
##

expected one of new line or EOF

translation_unit: HEADER MAIN_METH_SEP WHILE
##
## Ends in an error in state: 103.
##
## translation_unit -> HEADER list(NEWLINE) fxns MAIN_METH_SEP list(NEWLINE) . fxn list(NEWLINE) EOF [ # ]
##
## The known suffix of the stack is as follows:
## HEADER list(NEWLINE) fxns MAIN_METH_SEP list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 102, spurious reduction of production list(NEWLINE) ->
##

expected `Sub`

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE DIM ID AS ID EQ WEST WHILE
##
## Ends in an error in state: 59.
##
## arith_expr -> expr . AND expr [ OR NEWLINE EQ DOT AND ]
## arith_expr -> expr . OR expr [ OR NEWLINE EQ DOT AND ]
## arith_expr -> expr . DOT expr [ OR NEWLINE EQ DOT AND ]
## arith_expr -> expr . EQ expr [ OR NEWLINE EQ DOT AND ]
## stmt -> DIM ID AS ID EQ expr . NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## DIM ID AS ID EQ expr
##

expected new line

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE DIM ID AS ID EQ WHILE
##
## Ends in an error in state: 58.
##
## stmt -> DIM ID AS ID EQ . expr NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## DIM ID AS ID EQ
##

expected expression

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE DIM ID AS ID WHILE
##
## Ends in an error in state: 57.
##
## stmt -> DIM ID AS ID . EQ expr NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## DIM ID AS ID
##

expected `=`

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE DIM ID AS WHILE
##
## Ends in an error in state: 56.
##
## stmt -> DIM ID AS . ID EQ expr NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## DIM ID AS
##

expected type identifier

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE DIM ID WHILE
##
## Ends in an error in state: 55.
##
## stmt -> DIM ID . AS ID EQ expr NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## DIM ID
##

expected `As`

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE DIM WHILE
##
## Ends in an error in state: 54.
##
## stmt -> DIM . ID AS ID EQ expr NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## DIM
##

expected identifier

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE END SUB NEWLINE WHILE
##
## Ends in an error in state: 111.
##
## list(extension_fxn) -> extension_fxn . list(extension_fxn) [ MAIN_METH_SEP ]
##
## The known suffix of the stack is as follows:
## extension_fxn
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 108, spurious reduction of production nonempty_list(NEWLINE) -> NEWLINE
## In state 110, spurious reduction of production extension_fxn -> fxn nonempty_list(NEWLINE)
##

expected `Sub`

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE END SUB WHILE
##
## Ends in an error in state: 107.
##
## extension_fxn -> fxn . nonempty_list(NEWLINE) [ SUB MAIN_METH_SEP ]
##
## The known suffix of the stack is as follows:
## fxn
##

expected new line

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE END WHILE
##
## Ends in an error in state: 98.
##
## fxn -> SUB ID LPAREN RPAREN NEWLINE block END . SUB [ NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## SUB ID LPAREN RPAREN NEWLINE block END
##

expected `Sub`

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE ID LPAREN WEST COMMA WHILE
##
## Ends in an error in state: 40.
##
## separated_nonempty_list(COMMA,expr) -> expr COMMA . separated_nonempty_list(COMMA,expr) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

expected expression

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE ID LPAREN WEST WHILE
##
## Ends in an error in state: 30.
##
## arith_expr -> expr . AND expr [ RPAREN OR EQ DOT COMMA AND ]
## arith_expr -> expr . OR expr [ RPAREN OR EQ DOT COMMA AND ]
## arith_expr -> expr . DOT expr [ RPAREN OR EQ DOT COMMA AND ]
## arith_expr -> expr . EQ expr [ RPAREN OR EQ DOT COMMA AND ]
## separated_nonempty_list(COMMA,expr) -> expr . [ RPAREN ]
## separated_nonempty_list(COMMA,expr) -> expr . COMMA separated_nonempty_list(COMMA,expr) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## expr
##

expected one of new line, `.`, or an operator

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE ID LPAREN WHILE
##
## Ends in an error in state: 22.
##
## expr -> ID LPAREN . arguments RPAREN [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
##
## The known suffix of the stack is as follows:
## ID LPAREN
##

expected expression

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE ID WHILE
##
## Ends in an error in state: 21.
##
## expr -> ID . LPAREN arguments RPAREN [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## primary_expr -> ID . [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
##
## The known suffix of the stack is as follows:
## ID
##

expected one of new line, `.`, or an operator

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN NEWLINE ELSE NEWLINE END IF WHILE
##
## Ends in an error in state: 90.
##
## stmt -> IF expr THEN NEWLINE block ELSE NEWLINE block END IF . NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## IF expr THEN NEWLINE block ELSE NEWLINE block END IF
##

expected new line

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN NEWLINE ELSE NEWLINE END WHILE
##
## Ends in an error in state: 89.
##
## stmt -> IF expr THEN NEWLINE block ELSE NEWLINE block END . IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## IF expr THEN NEWLINE block ELSE NEWLINE block END
##

expected `If`

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN NEWLINE ELSE NEWLINE THEN
##
## Ends in an error in state: 88.
##
## stmt -> IF expr THEN NEWLINE block ELSE NEWLINE block . END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## IF expr THEN NEWLINE block ELSE NEWLINE block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 87, spurious reduction of production list(stmt) ->
## In state 66, spurious reduction of production block -> list(stmt)
##

expected statement

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN NEWLINE ELSE WHILE
##
## Ends in an error in state: 86.
##
## stmt -> IF expr THEN NEWLINE block ELSE . NEWLINE block END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## IF expr THEN NEWLINE block ELSE
##

expected new line

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN NEWLINE ELSEIF WEST THEN NEWLINE ELSE NEWLINE END IF WHILE
##
## Ends in an error in state: 83.
##
## elseif_stmt -> ELSEIF expr THEN NEWLINE block ELSE NEWLINE block END IF . NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## ELSEIF expr THEN NEWLINE block ELSE NEWLINE block END IF
##

expected new line

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN NEWLINE ELSEIF WEST THEN NEWLINE ELSE NEWLINE END WHILE
##
## Ends in an error in state: 82.
##
## elseif_stmt -> ELSEIF expr THEN NEWLINE block ELSE NEWLINE block END . IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## ELSEIF expr THEN NEWLINE block ELSE NEWLINE block END
##

expected `If`

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN NEWLINE ELSEIF WEST THEN NEWLINE ELSE NEWLINE THEN
##
## Ends in an error in state: 81.
##
## elseif_stmt -> ELSEIF expr THEN NEWLINE block ELSE NEWLINE block . END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## ELSEIF expr THEN NEWLINE block ELSE NEWLINE block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production list(stmt) ->
## In state 66, spurious reduction of production block -> list(stmt)
##

expected statement

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN NEWLINE ELSEIF WEST THEN NEWLINE ELSE WHILE
##
## Ends in an error in state: 79.
##
## elseif_stmt -> ELSEIF expr THEN NEWLINE block ELSE . NEWLINE block END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## ELSEIF expr THEN NEWLINE block ELSE
##

expected new line

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN NEWLINE ELSEIF WEST THEN NEWLINE END IF WHILE
##
## Ends in an error in state: 77.
##
## elseif_stmt -> ELSEIF expr THEN NEWLINE block END IF . NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## ELSEIF expr THEN NEWLINE block END IF
##

expected new line

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN NEWLINE ELSEIF WEST THEN NEWLINE END WHILE
##
## Ends in an error in state: 76.
##
## elseif_stmt -> ELSEIF expr THEN NEWLINE block END . IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## ELSEIF expr THEN NEWLINE block END
##

expected `If`

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN NEWLINE ELSEIF WEST THEN NEWLINE THEN
##
## Ends in an error in state: 75.
##
## elseif_stmt -> ELSEIF expr THEN NEWLINE block . elseif_stmt [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
## elseif_stmt -> ELSEIF expr THEN NEWLINE block . ELSE NEWLINE block END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
## elseif_stmt -> ELSEIF expr THEN NEWLINE block . END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## ELSEIF expr THEN NEWLINE block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 74, spurious reduction of production list(stmt) ->
## In state 66, spurious reduction of production block -> list(stmt)
##

expected statement

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN NEWLINE ELSEIF WEST THEN WHILE
##
## Ends in an error in state: 73.
##
## elseif_stmt -> ELSEIF expr THEN . NEWLINE block elseif_stmt [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
## elseif_stmt -> ELSEIF expr THEN . NEWLINE block ELSE NEWLINE block END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
## elseif_stmt -> ELSEIF expr THEN . NEWLINE block END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## ELSEIF expr THEN
##

expected new line

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN NEWLINE ELSEIF WEST WHILE
##
## Ends in an error in state: 72.
##
## arith_expr -> expr . AND expr [ THEN OR EQ DOT AND ]
## arith_expr -> expr . OR expr [ THEN OR EQ DOT AND ]
## arith_expr -> expr . DOT expr [ THEN OR EQ DOT AND ]
## arith_expr -> expr . EQ expr [ THEN OR EQ DOT AND ]
## elseif_stmt -> ELSEIF expr . THEN NEWLINE block elseif_stmt [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
## elseif_stmt -> ELSEIF expr . THEN NEWLINE block ELSE NEWLINE block END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
## elseif_stmt -> ELSEIF expr . THEN NEWLINE block END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## ELSEIF expr
##

expected one of `Then`, `.`, or an operator

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN NEWLINE ELSEIF WHILE
##
## Ends in an error in state: 71.
##
## elseif_stmt -> ELSEIF . expr THEN NEWLINE block elseif_stmt [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
## elseif_stmt -> ELSEIF . expr THEN NEWLINE block ELSE NEWLINE block END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
## elseif_stmt -> ELSEIF . expr THEN NEWLINE block END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## ELSEIF
##

expected expression

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN NEWLINE END IF WHILE
##
## Ends in an error in state: 69.
##
## stmt -> IF expr THEN NEWLINE block END IF . NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## IF expr THEN NEWLINE block END IF
##

expected new line

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN NEWLINE END WHILE
##
## Ends in an error in state: 68.
##
## stmt -> IF expr THEN NEWLINE block END . IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## IF expr THEN NEWLINE block END
##

expected `If`

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN NEWLINE THEN
##
## Ends in an error in state: 67.
##
## stmt -> IF expr THEN NEWLINE block . END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
## stmt -> IF expr THEN NEWLINE block . elseif_stmt [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
## stmt -> IF expr THEN NEWLINE block . ELSE NEWLINE block END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## IF expr THEN NEWLINE block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production list(stmt) ->
## In state 66, spurious reduction of production block -> list(stmt)
##

expected statement

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST THEN WHILE
##
## Ends in an error in state: 52.
##
## stmt -> IF expr THEN . NEWLINE block END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
## stmt -> IF expr THEN . NEWLINE block elseif_stmt [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
## stmt -> IF expr THEN . NEWLINE block ELSE NEWLINE block END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## IF expr THEN
##

expected new line

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WEST WHILE
##
## Ends in an error in state: 51.
##
## arith_expr -> expr . AND expr [ THEN OR EQ DOT AND ]
## arith_expr -> expr . OR expr [ THEN OR EQ DOT AND ]
## arith_expr -> expr . DOT expr [ THEN OR EQ DOT AND ]
## arith_expr -> expr . EQ expr [ THEN OR EQ DOT AND ]
## stmt -> IF expr . THEN NEWLINE block END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
## stmt -> IF expr . THEN NEWLINE block elseif_stmt [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
## stmt -> IF expr . THEN NEWLINE block ELSE NEWLINE block END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## IF expr
##

expected one of `Then`, `.`, or an operator

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE IF WHILE
##
## Ends in an error in state: 50.
##
## stmt -> IF . expr THEN NEWLINE block END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
## stmt -> IF . expr THEN NEWLINE block elseif_stmt [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
## stmt -> IF . expr THEN NEWLINE block ELSE NEWLINE block END IF NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## IF
##

expected expression

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE LPAREN WEST WHILE
##
## Ends in an error in state: 44.
##
## arith_expr -> expr . AND expr [ RPAREN OR EQ DOT AND ]
## arith_expr -> expr . OR expr [ RPAREN OR EQ DOT AND ]
## arith_expr -> expr . DOT expr [ RPAREN OR EQ DOT AND ]
## arith_expr -> expr . EQ expr [ RPAREN OR EQ DOT AND ]
## primary_expr -> LPAREN expr . RPAREN [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
##
## The known suffix of the stack is as follows:
## LPAREN expr
##

expected one of `)`, `.`, or an operator

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE LPAREN WHILE
##
## Ends in an error in state: 18.
##
## primary_expr -> LPAREN . expr RPAREN [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

expected expression

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE NEW WEST WHILE
##
## Ends in an error in state: 46.
##
## arith_expr -> expr . AND expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr . OR expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr . DOT expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr . EQ expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> NEW expr . [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
##
## The known suffix of the stack is as follows:
## NEW expr
##

expected one of new line, `.`, or an operator

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE NEW WHILE
##
## Ends in an error in state: 17.
##
## arith_expr -> NEW . expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
##
## The known suffix of the stack is as follows:
## NEW
##

expected expression

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE NOT WEST WHILE
##
## Ends in an error in state: 47.
##
## arith_expr -> expr . AND expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr . OR expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr . DOT expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr . EQ expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> NOT expr . [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
##
## The known suffix of the stack is as follows:
## NOT expr
##

expected one of new line, `.`, or an operator

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE NOT WHILE
##
## Ends in an error in state: 15.
##
## arith_expr -> NOT . expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
##
## The known suffix of the stack is as follows:
## NOT
##

expected expression

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE THEN
##
## Ends in an error in state: 97.
##
## fxn -> SUB ID LPAREN RPAREN NEWLINE block . END SUB [ NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## SUB ID LPAREN RPAREN NEWLINE block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 9, spurious reduction of production list(stmt) ->
## In state 66, spurious reduction of production block -> list(stmt)
##

expected statement

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE WEST AND WEST WHILE
##
## Ends in an error in state: 37.
##
## arith_expr -> expr . AND expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr AND expr . [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr . OR expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr . DOT expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr . EQ expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr AND expr
##

expected one of new line, `.`, or an operator

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE WEST AND WHILE
##
## Ends in an error in state: 36.
##
## arith_expr -> expr AND . expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr AND
##

expected expression

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE WEST DOT WHILE
##
## Ends in an error in state: 33.
##
## arith_expr -> expr DOT . expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr DOT
##

expected function call

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE WEST EQ WEST WHILE
##
## Ends in an error in state: 39.
##
## arith_expr -> expr . AND expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr . OR expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr . DOT expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr . EQ expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr EQ expr . [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr EQ expr
##

expected one of new line, `.`, or an operator

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE WEST EQ WHILE
##
## Ends in an error in state: 38.
##
## arith_expr -> expr EQ . expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr EQ
##

expected expression

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE WEST OR WEST WHILE
##
## Ends in an error in state: 32.
##
## arith_expr -> expr . AND expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr . OR expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr OR expr . [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr . DOT expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
## arith_expr -> expr . EQ expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr OR expr
##

expected one of new line, `.`, or an operator

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE WEST OR WHILE
##
## Ends in an error in state: 31.
##
## arith_expr -> expr OR . expr [ THEN RPAREN OR NEWLINE EQ DOT COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr OR
##

expected expression

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE WEST WHILE
##
## Ends in an error in state: 65.
##
## arith_expr -> expr . AND expr [ OR NEWLINE EQ DOT AND ]
## arith_expr -> expr . OR expr [ OR NEWLINE EQ DOT AND ]
## arith_expr -> expr . DOT expr [ OR NEWLINE EQ DOT AND ]
## arith_expr -> expr . EQ expr [ OR NEWLINE EQ DOT AND ]
## option(expr) -> expr . [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## expr
##

expected one of new line, `.`, or an operator

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE WHILE WEST NEWLINE END WEST
##
## Ends in an error in state: 94.
##
## stmt -> WHILE expr NEWLINE block END . WHILE NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## WHILE expr NEWLINE block END
##

expected `While`

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE WHILE WEST NEWLINE END WHILE WHILE
##
## Ends in an error in state: 95.
##
## stmt -> WHILE expr NEWLINE block END WHILE . NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## WHILE expr NEWLINE block END WHILE
##

expected new line

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE WHILE WEST NEWLINE THEN
##
## Ends in an error in state: 93.
##
## stmt -> WHILE expr NEWLINE block . END WHILE NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## WHILE expr NEWLINE block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 49, spurious reduction of production list(stmt) ->
## In state 66, spurious reduction of production block -> list(stmt)
##

expected statement

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE WHILE WEST WHILE
##
## Ends in an error in state: 48.
##
## arith_expr -> expr . AND expr [ OR NEWLINE EQ DOT AND ]
## arith_expr -> expr . OR expr [ OR NEWLINE EQ DOT AND ]
## arith_expr -> expr . DOT expr [ OR NEWLINE EQ DOT AND ]
## arith_expr -> expr . EQ expr [ OR NEWLINE EQ DOT AND ]
## stmt -> WHILE expr . NEWLINE block END WHILE NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## WHILE expr
##

expected one of new line, `.`, or an operator

translation_unit: HEADER SUB ID LPAREN RPAREN NEWLINE WHILE WHILE
##
## Ends in an error in state: 10.
##
## stmt -> WHILE . expr NEWLINE block END WHILE NEWLINE [ WHILE WEST TRUE SOUTH RIGHT NOT NORTH NEWLINE NEW LPAREN LEFT INT IF ID HERE FALSE END ELSEIF ELSE EAST DIM AHEAD ]
##
## The known suffix of the stack is as follows:
## WHILE
##

expected expression

translation_unit: HEADER SUB ID LPAREN RPAREN WHILE
##
## Ends in an error in state: 8.
##
## fxn -> SUB ID LPAREN RPAREN . NEWLINE block END SUB [ NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## SUB ID LPAREN RPAREN
##

expected block

translation_unit: HEADER SUB ID LPAREN WHILE
##
## Ends in an error in state: 7.
##
## fxn -> SUB ID LPAREN . RPAREN NEWLINE block END SUB [ NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## SUB ID LPAREN
##

expected `)`

translation_unit: HEADER SUB ID WHILE
##
## Ends in an error in state: 6.
##
## fxn -> SUB ID . LPAREN RPAREN NEWLINE block END SUB [ NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## SUB ID
##

expected `(`

translation_unit: HEADER SUB WHILE
##
## Ends in an error in state: 5.
##
## fxn -> SUB . ID LPAREN RPAREN NEWLINE block END SUB [ NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## SUB
##

expected identifier

translation_unit: HEADER WHILE
##
## Ends in an error in state: 4.
##
## translation_unit -> HEADER list(NEWLINE) . fxns MAIN_METH_SEP list(NEWLINE) fxn list(NEWLINE) EOF [ # ]
##
## The known suffix of the stack is as follows:
## HEADER list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
##

expected `Sub`

translation_unit: WHILE
##
## Ends in an error in state: 0.
##
## translation_unit' -> . translation_unit [ # ]
##
## The known suffix of the stack is as follows:
##
##

expected `@VB` (likely due to an error in your input file)
